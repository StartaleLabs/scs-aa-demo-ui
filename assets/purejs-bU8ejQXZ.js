import{b as pt,i as zt,c as yt,d as rt,e as Y,f as Xt,r as Wt,g as Qt,s as Jt,j as te,k as ee,u as ne,l as re}from"./index-CXC6VKm4.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Et=BigInt(0),mt=BigInt(1);function at(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function st(e){const n=e.toString(16);return n.length&1?"0"+n:n}function Ot(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Et:BigInt("0x"+e)}function lt(e){return Ot(rt(e))}function Tt(e){return yt(e),Ot(rt(Uint8Array.from(e).reverse()))}function Bt(e,n){return pt(e.toString(16).padStart(n*2,"0"))}function Kt(e,n){return Bt(e,n).reverse()}function $(e,n,t){let r;if(typeof n=="string")try{r=pt(n)}catch(i){throw new Error(e+" must be hex string or Uint8Array, cause: "+i)}else if(zt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const o=r.length;if(typeof t=="number"&&o!==t)throw new Error(e+" of length "+t+" expected, got "+o);return r}const ht=e=>typeof e=="bigint"&&Et<=e;function fe(e,n,t){return ht(e)&&ht(n)&&ht(t)&&n<=e&&e<t}function oe(e,n,t,r){if(!fe(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function ie(e){let n;for(n=0;e>Et;e>>=mt,n+=1);return n}const ut=e=>(mt<<BigInt(e))-mt;function se(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=x=>new Uint8Array(x),o=x=>Uint8Array.of(x);let i=r(e),f=r(e),u=0;const a=()=>{i.fill(1),f.fill(0),u=0},m=(...x)=>t(f,i,...x),s=(x=r(0))=>{f=m(o(0),x),i=m(),x.length!==0&&(f=m(o(1),x),i=m())},v=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let x=0;const R=[];for(;x<n;){i=m();const A=i.slice();R.push(A),x+=i.length}return Y(...R)};return(x,R)=>{a(),s(x);let A;for(;!(A=R(v()));)s();return a(),A}}function vt(e,n,t={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(o,i,f){const u=e[o];if(f&&u===void 0)return;const a=typeof u;if(a!==i||u===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${a}`)}Object.entries(n).forEach(([o,i])=>r(o,i,!1)),Object.entries(t).forEach(([o,i])=>r(o,i,!0))}function St(e){const n=new WeakMap;return(t,...r)=>{const o=n.get(t);if(o!==void 0)return o;const i=e(t,...r);return n.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),L=BigInt(1),G=BigInt(2),ce=BigInt(3),Lt=BigInt(4),Ut=BigInt(5),jt=BigInt(8);function H(e,n){const t=e%n;return t>=j?t:n+t}function It(e,n){if(e===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let t=H(e,n),r=n,o=j,i=L;for(;t!==j;){const u=r/t,a=r%t,m=o-i*u;r=t,t=a,o=i,i=m}if(r!==L)throw new Error("invert: does not exist");return H(o,n)}function $t(e,n){const t=(e.ORDER+L)/Lt,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function ae(e,n){const t=(e.ORDER-Ut)/jt,r=e.mul(n,G),o=e.pow(r,t),i=e.mul(n,o),f=e.mul(e.mul(i,G),o),u=e.mul(i,e.sub(f,e.ONE));if(!e.eql(e.sqr(u),n))throw new Error("Cannot find square root");return u}function le(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-L,t=0;for(;n%G===j;)n/=G,t++;let r=G;const o=W(e);for(;Nt(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return $t;let i=o.pow(r,n);const f=(n+L)/G;return function(a,m){if(a.is0(m))return m;if(Nt(a,m)!==1)throw new Error("Cannot find square root");let s=t,v=a.mul(a.ONE,i),S=a.pow(m,n),x=a.pow(m,f);for(;!a.eql(S,a.ONE);){if(a.is0(S))return a.ZERO;let R=1,A=a.sqr(S);for(;!a.eql(A,a.ONE);)if(R++,A=a.sqr(A),R===s)throw new Error("Cannot find square root");const U=L<<BigInt(s-R-1),V=a.pow(v,U);s=R,v=a.sqr(V),S=a.mul(S,v),x=a.mul(x,V)}return x}}function ue(e){return e%Lt===ce?$t:e%jt===Ut?ae:le(e)}const de=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function he(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=de.reduce((r,o)=>(r[o]="function",r),n);return vt(e,t),e}function we(e,n,t){if(t<j)throw new Error("invalid exponent, negatives unsupported");if(t===j)return e.ONE;if(t===L)return n;let r=e.ONE,o=n;for(;t>j;)t&L&&(r=e.mul(r,o)),o=e.sqr(o),t>>=L;return r}function Vt(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),o=n.reduce((f,u,a)=>e.is0(u)?f:(r[a]=f,e.mul(f,u)),e.ONE),i=e.inv(o);return n.reduceRight((f,u,a)=>e.is0(u)?f:(r[a]=e.mul(f,r[a]),e.mul(f,u)),i),r}function Nt(e,n){const t=(e.ORDER-L)/G,r=e.pow(n,t),o=e.eql(r,e.ONE),i=e.eql(r,e.ZERO),f=e.eql(r,e.neg(e.ONE));if(!o&&!i&&!f)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function ge(e,n){n!==void 0&&Xt(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function W(e,n,t=!1,r={}){if(e<=j)throw new Error("invalid field: expected ORDER > 0, got "+e);let o,i;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const s=n;s.BITS&&(o=s.BITS),s.sqrt&&(i=s.sqrt),typeof s.isLE=="boolean"&&(t=s.isLE)}else typeof n=="number"&&(o=n),r.sqrt&&(i=r.sqrt);const{nBitLength:f,nByteLength:u}=ge(e,o);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const m=Object.freeze({ORDER:e,isLE:t,BITS:f,BYTES:u,MASK:ut(f),ZERO:j,ONE:L,create:s=>H(s,e),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return j<=s&&s<e},is0:s=>s===j,isValidNot0:s=>!m.is0(s)&&m.isValid(s),isOdd:s=>(s&L)===L,neg:s=>H(-s,e),eql:(s,v)=>s===v,sqr:s=>H(s*s,e),add:(s,v)=>H(s+v,e),sub:(s,v)=>H(s-v,e),mul:(s,v)=>H(s*v,e),pow:(s,v)=>we(m,s,v),div:(s,v)=>H(s*It(v,e),e),sqrN:s=>s*s,addN:(s,v)=>s+v,subN:(s,v)=>s-v,mulN:(s,v)=>s*v,inv:s=>It(s,e),sqrt:i||(s=>(a||(a=ue(e)),a(m,s))),toBytes:s=>t?Kt(s,u):Bt(s,u),fromBytes:s=>{if(s.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+s.length);return t?Tt(s):lt(s)},invertBatch:s=>Vt(m,s),cmov:(s,v,S)=>S?v:s});return Object.freeze(m)}function Ht(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Ct(e){const n=Ht(e);return n+Math.ceil(n/2)}function be(e,n,t=!1){const r=e.length,o=Ht(n),i=Ct(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const f=t?Tt(e):lt(e),u=H(f,n-L)+L;return t?Kt(u,o):Bt(u,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const X=BigInt(0),D=BigInt(1);function tt(e,n){const t=n.negate();return e?t:n}function ye(e,n,t){const r=f=>f.pz,o=Vt(e.Fp,t.map(r));return t.map((f,u)=>f.toAffine(o[u])).map(e.fromAffine)}function Mt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function wt(e,n){Mt(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),o=2**e,i=ut(e),f=BigInt(e);return{windows:t,windowSize:r,mask:i,maxNumber:o,shiftBy:f}}function qt(e,n,t){const{windowSize:r,mask:o,maxNumber:i,shiftBy:f}=t;let u=Number(e&o),a=e>>f;u>r&&(u-=i,a+=D);const m=n*r,s=m+Math.abs(u)-1,v=u===0,S=u<0,x=n%2!==0;return{nextN:a,offset:s,isZero:v,isNeg:S,isNegF:x,offsetF:m}}function me(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function pe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const gt=new WeakMap,kt=new WeakMap;function bt(e){return kt.get(e)||1}function At(e){if(e!==X)throw new Error("invalid wNAF")}function Ee(e,n){return{constTimeNegate:tt,hasPrecomputes(t){return bt(t)!==1},unsafeLadder(t,r,o=e.ZERO){let i=t;for(;r>X;)r&D&&(o=o.add(i)),i=i.double(),r>>=D;return o},precomputeWindow(t,r){const{windows:o,windowSize:i}=wt(r,n),f=[];let u=t,a=u;for(let m=0;m<o;m++){a=u,f.push(a);for(let s=1;s<i;s++)a=a.add(u),f.push(a);u=a.double()}return f},wNAF(t,r,o){let i=e.ZERO,f=e.BASE;const u=wt(t,n);for(let a=0;a<u.windows;a++){const{nextN:m,offset:s,isZero:v,isNeg:S,isNegF:x,offsetF:R}=qt(o,a,u);o=m,v?f=f.add(tt(x,r[R])):i=i.add(tt(S,r[s]))}return At(o),{p:i,f}},wNAFUnsafe(t,r,o,i=e.ZERO){const f=wt(t,n);for(let u=0;u<f.windows&&o!==X;u++){const{nextN:a,offset:m,isZero:s,isNeg:v}=qt(o,u,f);if(o=a,!s){const S=r[m];i=i.add(v?S.negate():S)}}return At(o),i},getPrecomputes(t,r,o){let i=gt.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof o=="function"&&(i=o(i)),gt.set(r,i))),i},wNAFCached(t,r,o){const i=bt(t);return this.wNAF(i,this.getPrecomputes(i,t,o),r)},wNAFCachedUnsafe(t,r,o,i){const f=bt(t);return f===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(f,this.getPrecomputes(f,t,o),r,i)},setWindowSize(t,r){Mt(r,n),kt.set(t,r),gt.delete(t)}}}function Be(e,n,t,r){let o=n,i=e.ZERO,f=e.ZERO;for(;t>X||r>X;)t&D&&(i=i.add(o)),r&D&&(f=f.add(o)),o=o.double(),t>>=D,r>>=D;return{p1:i,p2:f}}function ve(e,n,t,r){me(t,e),pe(r,n);const o=t.length,i=r.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const f=e.ZERO,u=ie(BigInt(o));let a=1;u>12?a=u-3:u>4?a=u-2:u>0&&(a=2);const m=ut(a),s=new Array(Number(m)+1).fill(f),v=Math.floor((n.BITS-1)/a)*a;let S=f;for(let x=v;x>=0;x-=a){s.fill(f);for(let A=0;A<i;A++){const U=r[A],V=Number(U>>BigInt(x)&m);s[V]=s[V].add(t[A])}let R=f;for(let A=s.length-1,U=f;A>0;A--)U=U.add(s[A]),R=R.add(U);if(S=S.add(R),x!==0)for(let A=0;A<a;A++)S=S.double()}return S}function _t(e,n){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return he(n),n}else return W(e)}function xe(e,n,t={}){if(!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const u of["p","n","h"]){const a=n[u];if(!(typeof a=="bigint"&&a>X))throw new Error(`CURVE.${u} must be positive bigint`)}const r=_t(n.p,t.Fp),o=_t(n.n,t.Fn),f=["Gx","Gy","a","b"];for(const u of f)if(!r.isValid(n[u]))throw new Error(`CURVE.${u} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rt(e){e.lowS!==void 0&&at("lowS",e.lowS),e.prehash!==void 0&&at("prehash",e.prehash)}class Se extends Error{constructor(n=""){super(n)}}const C={Err:Se,_tlv:{encode:(e,n)=>{const{Err:t}=C;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,o=st(r);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?st(o.length/2|128):"";return st(e)+i+o+n},decode(e,n){const{Err:t}=C;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const o=n[r++],i=!!(o&128);let f=0;if(!i)f=o;else{const a=o&127;if(!a)throw new t("tlv.decode(long): indefinite length not supported");if(a>4)throw new t("tlv.decode(long): byte length is too big");const m=n.subarray(r,r+a);if(m.length!==a)throw new t("tlv.decode: length bytes not complete");if(m[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const s of m)f=f<<8|s;if(r+=a,f<128)throw new t("tlv.decode(long): not minimal encoding")}const u=n.subarray(r,r+f);if(u.length!==f)throw new t("tlv.decode: wrong value length");return{v:u,l:n.subarray(r+f)}}},_int:{encode(e){const{Err:n}=C;if(e<et)throw new n("integer: negative integers are not allowed");let t=st(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=C;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return lt(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=C,o=$("signature",e),{v:i,l:f}=r.decode(48,o);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:u,l:a}=r.decode(2,i),{v:m,l:s}=r.decode(2,a);if(s.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(u),s:t.decode(m)}},hexFromSig(e){const{_tlv:n,_int:t}=C,r=n.encode(2,t.encode(e.r)),o=n.encode(2,t.encode(e.s)),i=r+o;return n.encode(48,i)}},et=BigInt(0),nt=BigInt(1),Ie=BigInt(2),ct=BigInt(3),Ne=BigInt(4);function qe(e,n,t){function r(o){const i=e.sqr(o),f=e.mul(i,o);return e.add(e.add(f,e.mul(o,n)),t)}return r}function Yt(e,n,t){const{BYTES:r}=e;function o(i){let f;if(typeof i=="bigint")f=i;else{let u=$("private key",i);if(n){if(!n.includes(u.length*2))throw new Error("invalid private key");const a=new Uint8Array(r);a.set(u,a.length-u.length),u=a}try{f=e.fromBytes(u)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof i}`)}}if(t&&(f=e.create(f)),!e.isValidNot0(f))throw new Error("invalid private key: out of range [1..N-1]");return f}return o}function Ae(e,n={}){const{Fp:t,Fn:r}=xe("weierstrass",e,n),{h:o,n:i}=e;vt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:f}=n;if(f&&(!t.is0(e.a)||typeof f.beta!="bigint"||typeof f.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function u(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function a(_,c,h){const{x:l,y:d}=c.toAffine(),w=t.toBytes(l);if(at("isCompressed",h),h){u();const y=!t.isOdd(d);return Y(Gt(y),w)}else return Y(Uint8Array.of(4),w,t.toBytes(d))}function m(_){yt(_);const c=t.BYTES,h=c+1,l=2*c+1,d=_.length,w=_[0],y=_.subarray(1);if(d===h&&(w===2||w===3)){const g=t.fromBytes(y);if(!t.isValid(g))throw new Error("bad point: is not on curve, wrong x");const b=S(g);let E;try{E=t.sqrt(b)}catch(N){const B=N instanceof Error?": "+N.message:"";throw new Error("bad point: is not on curve, sqrt error"+B)}u();const p=t.isOdd(E);return(w&1)===1!==p&&(E=t.neg(E)),{x:g,y:E}}else if(d===l&&w===4){const g=t.fromBytes(y.subarray(c*0,c*1)),b=t.fromBytes(y.subarray(c*1,c*2));if(!x(g,b))throw new Error("bad point: is not on curve");return{x:g,y:b}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${l}`)}const s=n.toBytes||a,v=n.fromBytes||m,S=qe(t,e.a,e.b);function x(_,c){const h=t.sqr(c),l=S(_);return t.eql(h,l)}if(!x(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const R=t.mul(t.pow(e.a,ct),Ne),A=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(R,A)))throw new Error("bad curve params: a or b");function U(_,c,h=!1){if(!t.isValid(c)||h&&t.is0(c))throw new Error(`bad point coordinate ${_}`);return c}function V(_){if(!(_ instanceof I))throw new Error("ProjectivePoint expected")}const ft=St((_,c)=>{const{px:h,py:l,pz:d}=_;if(t.eql(d,t.ONE))return{x:h,y:l};const w=_.is0();c==null&&(c=w?t.ONE:t.inv(d));const y=t.mul(h,c),g=t.mul(l,c),b=t.mul(d,c);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:y,y:g}}),Q=St(_=>{if(_.is0()){if(n.allowInfinityPoint&&!t.is0(_.py))return;throw new Error("bad point: ZERO")}const{x:c,y:h}=_.toAffine();if(!t.isValid(c)||!t.isValid(h))throw new Error("bad point: x or y not field elements");if(!x(c,h))throw new Error("bad point: equation left != right");if(!_.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function ot(_,c,h,l,d){return h=new I(t.mul(h.px,_),h.py,h.pz),c=tt(l,c),h=tt(d,h),c.add(h)}class I{constructor(c,h,l){this.px=U("x",c),this.py=U("y",h,!0),this.pz=U("z",l),Object.freeze(this)}static fromAffine(c){const{x:h,y:l}=c||{};if(!c||!t.isValid(h)||!t.isValid(l))throw new Error("invalid affine point");if(c instanceof I)throw new Error("projective point not allowed");return t.is0(h)&&t.is0(l)?I.ZERO:new I(h,l,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){return ye(I,"pz",c)}static fromBytes(c){return yt(c),I.fromHex(c)}static fromHex(c){const h=I.fromAffine(v($("pointHex",c)));return h.assertValidity(),h}static fromPrivateKey(c){const h=Yt(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return I.BASE.multiply(h(c))}static msm(c,h){return ve(I,r,c,h)}precompute(c=8,h=!0){return M.setWindowSize(this,c),h||this.multiply(ct),this}_setWindowSize(c){this.precompute(c)}assertValidity(){Q(this)}hasEvenY(){const{y:c}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(c)}equals(c){V(c);const{px:h,py:l,pz:d}=this,{px:w,py:y,pz:g}=c,b=t.eql(t.mul(h,g),t.mul(w,d)),E=t.eql(t.mul(l,g),t.mul(y,d));return b&&E}negate(){return new I(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:h}=e,l=t.mul(h,ct),{px:d,py:w,pz:y}=this;let g=t.ZERO,b=t.ZERO,E=t.ZERO,p=t.mul(d,d),Z=t.mul(w,w),N=t.mul(y,y),B=t.mul(d,w);return B=t.add(B,B),E=t.mul(d,y),E=t.add(E,E),g=t.mul(c,E),b=t.mul(l,N),b=t.add(g,b),g=t.sub(Z,b),b=t.add(Z,b),b=t.mul(g,b),g=t.mul(B,g),E=t.mul(l,E),N=t.mul(c,N),B=t.sub(p,N),B=t.mul(c,B),B=t.add(B,E),E=t.add(p,p),p=t.add(E,p),p=t.add(p,N),p=t.mul(p,B),b=t.add(b,p),N=t.mul(w,y),N=t.add(N,N),p=t.mul(N,B),g=t.sub(g,p),E=t.mul(N,Z),E=t.add(E,E),E=t.add(E,E),new I(g,b,E)}add(c){V(c);const{px:h,py:l,pz:d}=this,{px:w,py:y,pz:g}=c;let b=t.ZERO,E=t.ZERO,p=t.ZERO;const Z=e.a,N=t.mul(e.b,ct);let B=t.mul(h,w),z=t.mul(l,y),O=t.mul(d,g),T=t.add(h,l),q=t.add(w,y);T=t.mul(T,q),q=t.add(B,z),T=t.sub(T,q),q=t.add(h,d);let K=t.add(w,g);return q=t.mul(q,K),K=t.add(B,O),q=t.sub(q,K),K=t.add(l,d),b=t.add(y,g),K=t.mul(K,b),b=t.add(z,O),K=t.sub(K,b),p=t.mul(Z,q),b=t.mul(N,O),p=t.add(b,p),b=t.sub(z,p),p=t.add(z,p),E=t.mul(b,p),z=t.add(B,B),z=t.add(z,B),O=t.mul(Z,O),q=t.mul(N,q),z=t.add(z,O),O=t.sub(B,O),O=t.mul(Z,O),q=t.add(q,O),B=t.mul(z,q),E=t.add(E,B),B=t.mul(K,q),b=t.mul(T,b),b=t.sub(b,B),B=t.mul(T,z),p=t.mul(K,p),p=t.add(p,B),new I(b,E,p)}subtract(c){return this.add(c.negate())}is0(){return this.equals(I.ZERO)}multiply(c){const{endo:h}=n;if(!r.isValidNot0(c))throw new Error("invalid scalar: out of range");let l,d;const w=y=>M.wNAFCached(this,y,I.normalizeZ);if(h){const{k1neg:y,k1:g,k2neg:b,k2:E}=h.splitScalar(c),{p,f:Z}=w(g),{p:N,f:B}=w(E);d=Z.add(B),l=ot(h.beta,p,N,y,b)}else{const{p:y,f:g}=w(c);l=y,d=g}return I.normalizeZ([l,d])[0]}multiplyUnsafe(c){const{endo:h}=n,l=this;if(!r.isValid(c))throw new Error("invalid scalar: out of range");if(c===et||l.is0())return I.ZERO;if(c===nt)return l;if(M.hasPrecomputes(this))return this.multiply(c);if(h){const{k1neg:d,k1:w,k2neg:y,k2:g}=h.splitScalar(c),{p1:b,p2:E}=Be(I,l,w,g);return ot(h.beta,b,E,d,y)}else return M.wNAFCachedUnsafe(l,c)}multiplyAndAddUnsafe(c,h,l){const d=this.multiplyUnsafe(h).add(c.multiplyUnsafe(l));return d.is0()?void 0:d}toAffine(c){return ft(this,c)}isTorsionFree(){const{isTorsionFree:c}=n;return o===nt?!0:c?c(I,this):M.wNAFCachedUnsafe(this,i).is0()}clearCofactor(){const{clearCofactor:c}=n;return o===nt?this:c?c(I,this):this.multiplyUnsafe(o)}toBytes(c=!0){return at("isCompressed",c),this.assertValidity(),s(I,this,c)}toRawBytes(c=!0){return this.toBytes(c)}toHex(c=!0){return rt(this.toBytes(c))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}I.BASE=new I(e.Gx,e.Gy,t.ONE),I.ZERO=new I(t.ZERO,t.ONE,t.ZERO),I.Fp=t,I.Fn=r;const it=r.BITS,M=Ee(I,n.endo?Math.ceil(it/2):it);return I}function Gt(e){return Uint8Array.of(e?2:3)}function _e(e,n,t={}){vt(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||Wt,o=n.hmac||((l,...d)=>Qt(n.hash,l,Y(...d))),{Fp:i,Fn:f}=e,{ORDER:u,BITS:a}=f;function m(l){const d=u>>nt;return l>d}function s(l){return m(l)?f.neg(l):l}function v(l,d){if(!f.isValidNot0(d))throw new Error(`invalid signature ${l}: out of range 1..CURVE.n`)}class S{constructor(d,w,y){v("r",d),v("s",w),this.r=d,this.s=w,y!=null&&(this.recovery=y),Object.freeze(this)}static fromCompact(d){const w=f.BYTES,y=$("compactSignature",d,w*2);return new S(f.fromBytes(y.subarray(0,w)),f.fromBytes(y.subarray(w,w*2)))}static fromDER(d){const{r:w,s:y}=C.toSig($("DER",d));return new S(w,y)}assertValidity(){}addRecoveryBit(d){return new S(this.r,this.s,d)}recoverPublicKey(d){const w=i.ORDER,{r:y,s:g,recovery:b}=this;if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");if(u*Ie<w&&b>1)throw new Error("recovery id is ambiguous for h>1 curve");const p=b===2||b===3?y+u:y;if(!i.isValid(p))throw new Error("recovery id 2 or 3 invalid");const Z=i.toBytes(p),N=e.fromHex(Y(Gt((b&1)===0),Z)),B=f.inv(p),z=Q($("msgHash",d)),O=f.create(-z*B),T=f.create(g*B),q=e.BASE.multiplyUnsafe(O).add(N.multiplyUnsafe(T));if(q.is0())throw new Error("point at infinify");return q.assertValidity(),q}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,f.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return Y(f.toBytes(this.r),f.toBytes(this.s));if(d==="der")return pt(C.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return rt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return rt(this.toBytes("compact"))}}const x=Yt(f,t.allowedPrivateKeyLengths,t.wrapPrivateKey),R={isValidPrivateKey(l){try{return x(l),!0}catch{return!1}},normPrivateKeyToScalar:x,randomPrivateKey:()=>{const l=u;return be(r(Ct(l)),l)},precompute(l=8,d=e.BASE){return d.precompute(l,!1)}};function A(l,d=!0){return e.fromPrivateKey(l).toBytes(d)}function U(l){if(typeof l=="bigint")return!1;if(l instanceof e)return!0;const w=$("key",l).length,y=i.BYTES,g=y+1,b=2*y+1;if(!(t.allowedPrivateKeyLengths||f.BYTES===g))return w===g||w===b}function V(l,d,w=!0){if(U(l)===!0)throw new Error("first arg must be private key");if(U(d)===!1)throw new Error("second arg must be public key");return e.fromHex(d).multiply(x(l)).toBytes(w)}const ft=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const d=lt(l),w=l.length*8-a;return w>0?d>>BigInt(w):d},Q=n.bits2int_modN||function(l){return f.create(ft(l))},ot=ut(a);function I(l){return oe("num < 2^"+a,l,et,ot),f.toBytes(l)}function it(l,d,w=M){if(["recovered","canonical"].some(T=>T in w))throw new Error("sign() legacy options not supported");const{hash:y}=n;let{lowS:g,prehash:b,extraEntropy:E}=w;g==null&&(g=!0),l=$("msgHash",l),Rt(w),b&&(l=$("prehashed msgHash",y(l)));const p=Q(l),Z=x(d),N=[I(Z),I(p)];if(E!=null&&E!==!1){const T=E===!0?r(i.BYTES):E;N.push($("extraEntropy",T))}const B=Y(...N),z=p;function O(T){const q=ft(T);if(!f.isValidNot0(q))return;const K=f.inv(q),J=e.BASE.multiply(q).toAffine(),F=f.create(J.x);if(F===et)return;const k=f.create(K*f.create(z+F*Z));if(k===et)return;let dt=(J.x===F?0:2)|Number(J.y&nt),P=k;return g&&m(k)&&(P=s(k),dt^=1),new S(F,P,dt)}return{seed:B,k2sig:O}}const M={lowS:n.lowS,prehash:!1},_={lowS:n.lowS,prehash:!1};function c(l,d,w=M){const{seed:y,k2sig:g}=it(l,d,w);return se(n.hash.outputLen,f.BYTES,o)(y,g)}e.BASE.precompute(8);function h(l,d,w,y=_){const g=l;d=$("msgHash",d),w=$("publicKey",w),Rt(y);const{lowS:b,prehash:E,format:p}=y;if("strict"in y)throw new Error("options.strict was renamed to lowS");if(p!==void 0&&!["compact","der","js"].includes(p))throw new Error('format must be "compact", "der" or "js"');const Z=typeof g=="string"||zt(g),N=!Z&&!p&&typeof g=="object"&&g!==null&&typeof g.r=="bigint"&&typeof g.s=="bigint";if(!Z&&!N)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let B,z;try{if(N)if(p===void 0||p==="js")B=new S(g.r,g.s);else throw new Error("invalid format");if(Z){try{p!=="compact"&&(B=S.fromDER(g))}catch(P){if(!(P instanceof C.Err))throw P}!B&&p!=="der"&&(B=S.fromCompact(g))}z=e.fromHex(w)}catch{return!1}if(!B||b&&B.hasHighS())return!1;E&&(d=n.hash(d));const{r:O,s:T}=B,q=Q(d),K=f.inv(T),J=f.create(q*K),F=f.create(O*K),k=e.BASE.multiplyUnsafe(J).add(z.multiplyUnsafe(F));return k.is0()?!1:f.create(k.x)===O}return Object.freeze({getPublicKey:A,getSharedSecret:V,sign:c,verify:h,utils:R,Point:e,Signature:S})}function Re(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=W(n.n,e.nBitLength),o={Fp:t,Fn:r,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:o}}function Ze(e){const{CURVE:n,curveOpts:t}=Re(e),r={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,ecdsaOpts:r}}function ze(e,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:e})}function Oe(e){const{CURVE:n,curveOpts:t,ecdsaOpts:r}=Ze(e),o=Ae(n,t),i=_e(o,r,t);return ze(e,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function xt(e,n){const t=r=>Oe({...e,hash:r});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dt={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},Ft={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},Pt={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},Te=W(Dt.p),Ke=W(Ft.p),Le=W(Pt.p),Ue=xt({...Dt,Fp:Te,lowS:!1},Jt);xt({...Ft,Fp:Ke,lowS:!1},te);xt({...Pt,Fp:Le,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},ee);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt=Ue,$e=async e=>{const n=Zt.getPublicKey(e.privateKey,!0),t=ne(n);if(t!=e.publicKey)throw new Error(`Bad API key. Expected to get public key ${e.publicKey}, got ${t}`);const r=re().update(e.content).digest();return Zt.sign(r,e.privateKey).toDERHex()};export{$e as signWithApiKey};
