import{ab as fe,ac as _t,ad as It,ae as ce,af as ae,ag as Ce,ah as gt,ai as jt,aj as _e,ak as Re,al as Te,am as ze,an as Ze,ao as $,ap as ke,aq as W,ar as ut,as as Xt,at as ht,au as Qt,av as vt,aw as St,ax as Ve,ay as Me,az as Ge,aA as Ke,aB as De,a7 as Fe,aC as je}from"./index-rE57GkpX.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt(0),Kt=BigInt(1);function Et(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Wt(e){if(!Et(e))throw new Error("Uint8Array expected")}function yt(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function Ht(e){const n=e.toString(16);return n.length&1?"0"+n:n}function le(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Yt:BigInt("0x"+e)}const de=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ye=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function mt(e){if(Wt(e),de)return e.toHex();let n="";for(let t=0;t<e.length;t++)n+=Ye[e[t]];return n}const X={_0:48,_9:57,A:65,F:70,a:97,f:102};function Jt(e){if(e>=X._0&&e<=X._9)return e-X._0;if(e>=X.A&&e<=X.F)return e-(X.A-10);if(e>=X.a&&e<=X.f)return e-(X.a-10)}function Nt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(de)return Uint8Array.fromHex(e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){const f=Jt(e.charCodeAt(o)),c=Jt(e.charCodeAt(o+1));if(f===void 0||c===void 0){const s=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}r[i]=f*16+c}return r}function ct(e){return le(mt(e))}function ue(e){return Wt(e),le(mt(Uint8Array.from(e).reverse()))}function Bt(e,n){return Nt(e.toString(16).padStart(n*2,"0"))}function he(e,n){return Bt(e,n).reverse()}function F(e,n,t){let r;if(typeof n=="string")try{r=Nt(n)}catch(o){throw new Error(e+" must be hex string or Uint8Array, cause: "+o)}else if(Et(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}function Ot(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];Wt(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const o=e[r];t.set(o,i),i+=o.length}return t}const Rt=e=>typeof e=="bigint"&&Yt<=e;function Pt(e,n,t){return Rt(e)&&Rt(n)&&Rt(t)&&n<=e&&e<t}function bt(e,n,t,r){if(!Pt(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function We(e){let n;for(n=0;e>Yt;e>>=Kt,n+=1);return n}const Lt=e=>(Kt<<BigInt(e))-Kt,Tt=e=>new Uint8Array(e),te=e=>Uint8Array.from(e);function Pe(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Tt(e),i=Tt(e),o=0;const f=()=>{r.fill(1),i.fill(0),o=0},c=(...h)=>t(i,r,...h),s=(h=Tt(0))=>{i=c(te([0]),h),r=c(),h.length!==0&&(i=c(te([1]),h),r=c())},d=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const p=[];for(;h<n;){r=c();const I=r.slice();p.push(I),h+=r.length}return Ot(...p)};return(h,p)=>{f(),s(h);let I;for(;!(I=p(d()));)s();return f(),I}}const $e={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||Et(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function qt(e,n,t={}){const r=(i,o,f)=>{const c=$e[o];if(typeof c!="function")throw new Error("invalid validator function");const s=e[i];if(!(f&&s===void 0)&&!c(s,e))throw new Error("param "+String(i)+" is invalid. Expected "+o+", got "+s)};for(const[i,o]of Object.entries(n))r(i,o,!1);for(const[i,o]of Object.entries(t))r(i,o,!0);return e}function ee(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const o=e(t,...r);return n.set(t,o),o}}function Xe(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);const i=BigInt(32),o=BigInt(4294967295),f=Number(t>>i&o),c=Number(t&o),s=r?4:0,d=r?0:4;e.setUint32(n+s,f,r),e.setUint32(n+d,c,r)}function Qe(e,n,t){return e&n^~e&t}function Je(e,n,t){return e&n^e&t^n&t}class be extends fe{constructor(n,t,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(n),this.view=_t(this.buffer)}update(n){It(this),n=ce(n),ae(n);const{view:t,buffer:r,blockLen:i}=this,o=n.length;for(let f=0;f<o;){const c=Math.min(i-this.pos,o-f);if(c===i){const s=_t(n);for(;i<=o-f;f+=i)this.process(s,f);continue}r.set(n.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){It(this),Ce(n,this),this.finished=!0;const{buffer:t,view:r,blockLen:i,isLE:o}=this;let{pos:f}=this;t[f++]=128,gt(this.buffer.subarray(f)),this.padOffset>i-f&&(this.process(r,0),f=0);for(let h=f;h<i;h++)t[h]=0;Xe(r,i-8,BigInt(this.length*8),o),this.process(r,0);const c=_t(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=s/4,x=this.get();if(d>x.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)c.setUint32(4*h,x[h],o)}digest(){const{buffer:n,outputLen:t}=this;this.digestInto(n);const r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:t,buffer:r,length:i,finished:o,destroyed:f,pos:c}=this;return n.destroyed=f,n.finished=o,n.length=i,n.pos=c,i%t&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Z=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),k=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),tn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array(64);class en extends be{constructor(n=32){super(64,n,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:n,B:t,C:r,D:i,E:o,F:f,G:c,H:s}=this;return[n,t,r,i,o,f,c,s]}set(n,t,r,i,o,f,c,s){this.A=n|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=o|0,this.F=f|0,this.G=c|0,this.H=s|0}process(n,t){for(let h=0;h<16;h++,t+=4)nt[h]=n.getUint32(t,!1);for(let h=16;h<64;h++){const p=nt[h-15],I=nt[h-2],U=W(p,7)^W(p,18)^p>>>3,g=W(I,17)^W(I,19)^I>>>10;nt[h]=g+nt[h-7]+U+nt[h-16]|0}let{A:r,B:i,C:o,D:f,E:c,F:s,G:d,H:x}=this;for(let h=0;h<64;h++){const p=W(c,6)^W(c,11)^W(c,25),I=x+p+Qe(c,s,d)+tn[h]+nt[h]|0,g=(W(r,2)^W(r,13)^W(r,22))+Je(r,i,o)|0;x=d,d=s,s=c,c=f+I|0,f=o,o=i,i=r,r=I+g|0}r=r+this.A|0,i=i+this.B|0,o=o+this.C|0,f=f+this.D|0,c=c+this.E|0,s=s+this.F|0,d=d+this.G|0,x=x+this.H|0,this.set(r,i,o,f,c,s,d,x)}roundClean(){gt(nt)}destroy(){this.set(0,0,0,0,0,0,0,0),gt(this.buffer)}}const ge=ze(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),nn=ge[0],rn=ge[1],rt=new Uint32Array(80),st=new Uint32Array(80);class we extends be{constructor(n=64){super(128,n,16,!1),this.Ah=k[0]|0,this.Al=k[1]|0,this.Bh=k[2]|0,this.Bl=k[3]|0,this.Ch=k[4]|0,this.Cl=k[5]|0,this.Dh=k[6]|0,this.Dl=k[7]|0,this.Eh=k[8]|0,this.El=k[9]|0,this.Fh=k[10]|0,this.Fl=k[11]|0,this.Gh=k[12]|0,this.Gl=k[13]|0,this.Hh=k[14]|0,this.Hl=k[15]|0}get(){const{Ah:n,Al:t,Bh:r,Bl:i,Ch:o,Cl:f,Dh:c,Dl:s,Eh:d,El:x,Fh:h,Fl:p,Gh:I,Gl:U,Hh:g,Hl:R}=this;return[n,t,r,i,o,f,c,s,d,x,h,p,I,U,g,R]}set(n,t,r,i,o,f,c,s,d,x,h,p,I,U,g,R){this.Ah=n|0,this.Al=t|0,this.Bh=r|0,this.Bl=i|0,this.Ch=o|0,this.Cl=f|0,this.Dh=c|0,this.Dl=s|0,this.Eh=d|0,this.El=x|0,this.Fh=h|0,this.Fl=p|0,this.Gh=I|0,this.Gl=U|0,this.Hh=g|0,this.Hl=R|0}process(n,t){for(let w=0;w<16;w++,t+=4)rt[w]=n.getUint32(t),st[w]=n.getUint32(t+=4);for(let w=16;w<80;w++){const a=rt[w-15]|0,b=st[w-15]|0,m=ut(a,b,1)^ut(a,b,8)^Xt(a,b,7),A=ht(a,b,1)^ht(a,b,8)^Qt(a,b,7),v=rt[w-2]|0,O=st[w-2]|0,q=ut(v,O,19)^vt(v,O,61)^Xt(v,O,6),E=ht(v,O,19)^St(v,O,61)^Qt(v,O,6),H=_e(A,E,st[w-7],st[w-16]),B=Re(H,m,q,rt[w-7],rt[w-16]);rt[w]=B|0,st[w]=H|0}let{Ah:r,Al:i,Bh:o,Bl:f,Ch:c,Cl:s,Dh:d,Dl:x,Eh:h,El:p,Fh:I,Fl:U,Gh:g,Gl:R,Hh:C,Hl:G}=this;for(let w=0;w<80;w++){const a=ut(h,p,14)^ut(h,p,18)^vt(h,p,41),b=ht(h,p,14)^ht(h,p,18)^St(h,p,41),m=h&I^~h&g,A=p&U^~p&R,v=Te(G,b,A,rn[w],st[w]),O=Ze(v,C,a,m,nn[w],rt[w]),q=v|0,E=ut(r,i,28)^vt(r,i,34)^vt(r,i,39),H=ht(r,i,28)^St(r,i,34)^St(r,i,39),B=r&o^r&c^o&c,T=i&f^i&s^f&s;C=g|0,G=R|0,g=I|0,R=U|0,I=h|0,U=p|0,{h,l:p}=$(d|0,x|0,O|0,q|0),d=c|0,x=s|0,c=o|0,s=f|0,o=r|0,f=i|0;const u=Ve(q,H,T);r=ke(u,O,E,B),i=u|0}({h:r,l:i}=$(this.Ah|0,this.Al|0,r|0,i|0)),{h:o,l:f}=$(this.Bh|0,this.Bl|0,o|0,f|0),{h:c,l:s}=$(this.Ch|0,this.Cl|0,c|0,s|0),{h:d,l:x}=$(this.Dh|0,this.Dl|0,d|0,x|0),{h,l:p}=$(this.Eh|0,this.El|0,h|0,p|0),{h:I,l:U}=$(this.Fh|0,this.Fl|0,I|0,U|0),{h:g,l:R}=$(this.Gh|0,this.Gl|0,g|0,R|0),{h:C,l:G}=$(this.Hh|0,this.Hl|0,C|0,G|0),this.set(r,i,o,f,c,s,d,x,h,p,I,U,g,R,C,G)}roundClean(){gt(rt,st)}destroy(){gt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class sn extends we{constructor(){super(48),this.Ah=Z[0]|0,this.Al=Z[1]|0,this.Bh=Z[2]|0,this.Bl=Z[3]|0,this.Ch=Z[4]|0,this.Cl=Z[5]|0,this.Dh=Z[6]|0,this.Dl=Z[7]|0,this.Eh=Z[8]|0,this.El=Z[9]|0,this.Fh=Z[10]|0,this.Fl=Z[11]|0,this.Gh=Z[12]|0,this.Gl=Z[13]|0,this.Hh=Z[14]|0,this.Hl=Z[15]|0}}const on=jt(()=>new en),fn=jt(()=>new we),cn=jt(()=>new sn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),M=BigInt(1),ft=BigInt(2),an=BigInt(3),xe=BigInt(4),pe=BigInt(5),ye=BigInt(8);function j(e,n){const t=e%n;return t>=D?t:n+t}function Dt(e,n){if(e===D)throw new Error("invert: expected non-zero number");if(n<=D)throw new Error("invert: expected positive modulus, got "+n);let t=j(e,n),r=n,i=D,o=M;for(;t!==D;){const c=r/t,s=r%t,d=i-o*c;r=t,t=s,i=o,o=d}if(r!==M)throw new Error("invert: does not exist");return j(i,n)}function me(e,n){const t=(e.ORDER+M)/xe,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function ln(e,n){const t=(e.ORDER-pe)/ye,r=e.mul(n,ft),i=e.pow(r,t),o=e.mul(n,i),f=e.mul(e.mul(o,ft),i),c=e.mul(o,e.sub(f,e.ONE));if(!e.eql(e.sqr(c),n))throw new Error("Cannot find square root");return c}function dn(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-M,t=0;for(;n%ft===D;)n/=ft,t++;let r=ft;const i=At(e);for(;ne(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return me;let o=i.pow(r,n);const f=(n+M)/ft;return function(s,d){if(s.is0(d))return d;if(ne(s,d)!==1)throw new Error("Cannot find square root");let x=t,h=s.mul(s.ONE,o),p=s.pow(d,n),I=s.pow(d,f);for(;!s.eql(p,s.ONE);){if(s.is0(p))return s.ZERO;let U=1,g=s.sqr(p);for(;!s.eql(g,s.ONE);)if(U++,g=s.sqr(g),U===x)throw new Error("Cannot find square root");const R=M<<BigInt(x-U-1),C=s.pow(h,R);x=U,h=s.sqr(C),p=s.mul(p,h),I=s.mul(I,C)}return I}}function un(e){return e%xe===an?me:e%ye===pe?ln:dn(e)}const hn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function bn(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=hn.reduce((r,i)=>(r[i]="function",r),n);return qt(e,t)}function gn(e,n,t){if(t<D)throw new Error("invalid exponent, negatives unsupported");if(t===D)return e.ONE;if(t===M)return n;let r=e.ONE,i=n;for(;t>D;)t&M&&(r=e.mul(r,i)),i=e.sqr(i),t>>=M;return r}function Ee(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((f,c,s)=>e.is0(c)?f:(r[s]=f,e.mul(f,c)),e.ONE),o=e.inv(i);return n.reduceRight((f,c,s)=>e.is0(c)?f:(r[s]=e.mul(f,r[s]),e.mul(f,c)),o),r}function ne(e,n){const t=(e.ORDER-M)/ft,r=e.pow(n,t),i=e.eql(r,e.ONE),o=e.eql(r,e.ZERO),f=e.eql(r,e.neg(e.ONE));if(!i&&!o&&!f)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Be(e,n){n!==void 0&&Me(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function At(e,n,t=!1,r={}){if(e<=D)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:o}=Be(e,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const c=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:o,MASK:Lt(i),ZERO:D,ONE:M,create:s=>j(s,e),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return D<=s&&s<e},is0:s=>s===D,isOdd:s=>(s&M)===M,neg:s=>j(-s,e),eql:(s,d)=>s===d,sqr:s=>j(s*s,e),add:(s,d)=>j(s+d,e),sub:(s,d)=>j(s-d,e),mul:(s,d)=>j(s*d,e),pow:(s,d)=>gn(c,s,d),div:(s,d)=>j(s*Dt(d,e),e),sqrN:s=>s*s,addN:(s,d)=>s+d,subN:(s,d)=>s-d,mulN:(s,d)=>s*d,inv:s=>Dt(s,e),sqrt:r.sqrt||(s=>(f||(f=un(e)),f(c,s))),toBytes:s=>t?he(s,o):Bt(s,o),fromBytes:s=>{if(s.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+s.length);return t?ue(s):ct(s)},invertBatch:s=>Ee(c,s),cmov:(s,d,x)=>x?d:s});return Object.freeze(c)}function Ae(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function ve(e){const n=Ae(e);return n+Math.ceil(n/2)}function wn(e,n,t=!1){const r=e.length,i=Ae(n),o=ve(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const f=t?ue(e):ct(e),c=j(f,n-M)+M;return t?he(c,i):Bt(c,i)}class Se extends fe{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,Ge(n);const r=ce(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(r.length>i?n.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=n.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),gt(o)}update(n){return It(this),this.iHash.update(n),this}digestInto(n){It(this),ae(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:i,destroyed:o,blockLen:f,outputLen:c}=this;return n=n,n.finished=i,n.destroyed=o,n.blockLen=f,n.outputLen=c,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const He=(e,n,t)=>new Se(e,n).update(t).digest();He.create=(e,n)=>new Se(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const re=BigInt(0),Ft=BigInt(1);function zt(e,n){const t=n.negate();return e?t:n}function Ie(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Zt(e,n){Ie(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,o=Lt(e),f=BigInt(e);return{windows:t,windowSize:r,mask:o,maxNumber:i,shiftBy:f}}function se(e,n,t){const{windowSize:r,mask:i,maxNumber:o,shiftBy:f}=t;let c=Number(e&i),s=e>>f;c>r&&(c-=o,s+=Ft);const d=n*r,x=d+Math.abs(c)-1,h=c===0,p=c<0,I=n%2!==0;return{nextN:s,offset:x,isZero:h,isNeg:p,isNegF:I,offsetF:d}}function xn(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function pn(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const kt=new WeakMap,Ne=new WeakMap;function Vt(e){return Ne.get(e)||1}function yn(e,n){return{constTimeNegate:zt,hasPrecomputes(t){return Vt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let o=t;for(;r>re;)r&Ft&&(i=i.add(o)),o=o.double(),r>>=Ft;return i},precomputeWindow(t,r){const{windows:i,windowSize:o}=Zt(r,n),f=[];let c=t,s=c;for(let d=0;d<i;d++){s=c,f.push(s);for(let x=1;x<o;x++)s=s.add(c),f.push(s);c=s.double()}return f},wNAF(t,r,i){let o=e.ZERO,f=e.BASE;const c=Zt(t,n);for(let s=0;s<c.windows;s++){const{nextN:d,offset:x,isZero:h,isNeg:p,isNegF:I,offsetF:U}=se(i,s,c);i=d,h?f=f.add(zt(I,r[U])):o=o.add(zt(p,r[x]))}return{p:o,f}},wNAFUnsafe(t,r,i,o=e.ZERO){const f=Zt(t,n);for(let c=0;c<f.windows&&i!==re;c++){const{nextN:s,offset:d,isZero:x,isNeg:h}=se(i,c,f);if(i=s,!x){const p=r[d];o=o.add(h?p.negate():p)}}return o},getPrecomputes(t,r,i){let o=kt.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&kt.set(r,i(o))),o},wNAFCached(t,r,i){const o=Vt(t);return this.wNAF(o,this.getPrecomputes(o,t,i),r)},wNAFCachedUnsafe(t,r,i,o){const f=Vt(t);return f===1?this.unsafeLadder(t,r,o):this.wNAFUnsafe(f,this.getPrecomputes(f,t,i),r,o)},setWindowSize(t,r){Ie(r,n),Ne.set(t,r),kt.delete(t)}}}function mn(e,n,t,r){xn(t,e),pn(r,n);const i=t.length,o=r.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const f=e.ZERO,c=We(BigInt(i));let s=1;c>12?s=c-3:c>4?s=c-2:c>0&&(s=2);const d=Lt(s),x=new Array(Number(d)+1).fill(f),h=Math.floor((n.BITS-1)/s)*s;let p=f;for(let I=h;I>=0;I-=s){x.fill(f);for(let g=0;g<o;g++){const R=r[g],C=Number(R>>BigInt(I)&d);x[C]=x[C].add(t[g])}let U=f;for(let g=x.length-1,R=f;g>0;g--)R=R.add(x[g]),U=U.add(R);if(p=p.add(U),I!==0)for(let g=0;g<s;g++)p=p.double()}return p}function Oe(e){return bn(e.Fp),qt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Be(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ie(e){e.lowS!==void 0&&yt("lowS",e.lowS),e.prehash!==void 0&&yt("prehash",e.prehash)}function En(e){const n=Oe(e);qt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class Bn extends Error{constructor(n=""){super(n)}}const Q={Err:Bn,_tlv:{encode:(e,n)=>{const{Err:t}=Q;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=Ht(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const o=r>127?Ht(i.length/2|128):"";return Ht(e)+o+i+n},decode(e,n){const{Err:t}=Q;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],o=!!(i&128);let f=0;if(!o)f=i;else{const s=i&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+s);if(d.length!==s)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const x of d)f=f<<8|x;if(r+=s,f<128)throw new t("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+f);if(c.length!==f)throw new t("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+f)}}},_int:{encode(e){const{Err:n}=Q;if(e<J)throw new n("integer: negative integers are not allowed");let t=Ht(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=Q;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ct(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=Q,i=F("signature",e),{v:o,l:f}=r.decode(48,i);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:s}=r.decode(2,o),{v:d,l:x}=r.decode(2,s);if(x.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(d)}},hexFromSig(e){const{_tlv:n,_int:t}=Q,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),o=r+i;return n.encode(48,o)}};function Mt(e,n){return mt(Bt(e,n))}const J=BigInt(0),z=BigInt(1);BigInt(2);const Gt=BigInt(3),An=BigInt(4);function vn(e){const n=En(e),{Fp:t}=n,r=At(n.n,n.nBitLength),i=n.toBytes||((w,a,b)=>{const m=a.toAffine();return Ot(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),o=n.fromBytes||(w=>{const a=w.subarray(1),b=t.fromBytes(a.subarray(0,t.BYTES)),m=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:b,y:m}});function f(w){const{a,b}=n,m=t.sqr(w),A=t.mul(m,w);return t.add(t.add(A,t.mul(w,a)),b)}function c(w,a){const b=t.sqr(a),m=f(w);return t.eql(b,m)}if(!c(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const s=t.mul(t.pow(n.a,Gt),An),d=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(s,d)))throw new Error("bad curve params: a or b");function x(w){return Pt(w,z,n.n)}function h(w){const{allowedPrivateKeyLengths:a,nByteLength:b,wrapPrivateKey:m,n:A}=n;if(a&&typeof w!="bigint"){if(Et(w)&&(w=mt(w)),typeof w!="string"||!a.includes(w.length))throw new Error("invalid private key");w=w.padStart(b*2,"0")}let v;try{v=typeof w=="bigint"?w:ct(F("private key",w,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof w)}return m&&(v=j(v,A)),bt("private key",v,z,A),v}function p(w){if(!(w instanceof g))throw new Error("ProjectivePoint expected")}const I=ee((w,a)=>{const{px:b,py:m,pz:A}=w;if(t.eql(A,t.ONE))return{x:b,y:m};const v=w.is0();a==null&&(a=v?t.ONE:t.inv(A));const O=t.mul(b,a),q=t.mul(m,a),E=t.mul(A,a);if(v)return{x:t.ZERO,y:t.ZERO};if(!t.eql(E,t.ONE))throw new Error("invZ was invalid");return{x:O,y:q}}),U=ee(w=>{if(w.is0()){if(n.allowInfinityPoint&&!t.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:a,y:b}=w.toAffine();if(!t.isValid(a)||!t.isValid(b))throw new Error("bad point: x or y not FE");if(!c(a,b))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(a,b,m){if(a==null||!t.isValid(a))throw new Error("x required");if(b==null||!t.isValid(b)||t.is0(b))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");this.px=a,this.py=b,this.pz=m,Object.freeze(this)}static fromAffine(a){const{x:b,y:m}=a||{};if(!a||!t.isValid(b)||!t.isValid(m))throw new Error("invalid affine point");if(a instanceof g)throw new Error("projective point not allowed");const A=v=>t.eql(v,t.ZERO);return A(b)&&A(m)?g.ZERO:new g(b,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const b=Ee(t,a.map(m=>m.pz));return a.map((m,A)=>m.toAffine(b[A])).map(g.fromAffine)}static fromHex(a){const b=g.fromAffine(o(F("pointHex",a)));return b.assertValidity(),b}static fromPrivateKey(a){return g.BASE.multiply(h(a))}static msm(a,b){return mn(g,r,a,b)}_setWindowSize(a){G.setWindowSize(this,a)}assertValidity(){U(this)}hasEvenY(){const{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){p(a);const{px:b,py:m,pz:A}=this,{px:v,py:O,pz:q}=a,E=t.eql(t.mul(b,q),t.mul(v,A)),H=t.eql(t.mul(m,q),t.mul(O,A));return E&&H}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a,b}=n,m=t.mul(b,Gt),{px:A,py:v,pz:O}=this;let q=t.ZERO,E=t.ZERO,H=t.ZERO,B=t.mul(A,A),T=t.mul(v,v),u=t.mul(O,O),l=t.mul(A,v);return l=t.add(l,l),H=t.mul(A,O),H=t.add(H,H),q=t.mul(a,H),E=t.mul(m,u),E=t.add(q,E),q=t.sub(T,E),E=t.add(T,E),E=t.mul(q,E),q=t.mul(l,q),H=t.mul(m,H),u=t.mul(a,u),l=t.sub(B,u),l=t.mul(a,l),l=t.add(l,H),H=t.add(B,B),B=t.add(H,B),B=t.add(B,u),B=t.mul(B,l),E=t.add(E,B),u=t.mul(v,O),u=t.add(u,u),B=t.mul(u,l),q=t.sub(q,B),H=t.mul(u,T),H=t.add(H,H),H=t.add(H,H),new g(q,E,H)}add(a){p(a);const{px:b,py:m,pz:A}=this,{px:v,py:O,pz:q}=a;let E=t.ZERO,H=t.ZERO,B=t.ZERO;const T=n.a,u=t.mul(n.b,Gt);let l=t.mul(b,v),y=t.mul(m,O),L=t.mul(A,q),S=t.add(b,m),N=t.add(v,O);S=t.mul(S,N),N=t.add(l,y),S=t.sub(S,N),N=t.add(b,A);let _=t.add(v,q);return N=t.mul(N,_),_=t.add(l,L),N=t.sub(N,_),_=t.add(m,A),E=t.add(O,q),_=t.mul(_,E),E=t.add(y,L),_=t.sub(_,E),B=t.mul(T,N),E=t.mul(u,L),B=t.add(E,B),E=t.sub(y,B),B=t.add(y,B),H=t.mul(E,B),y=t.add(l,l),y=t.add(y,l),L=t.mul(T,L),N=t.mul(u,N),y=t.add(y,L),L=t.sub(l,L),L=t.mul(T,L),N=t.add(N,L),l=t.mul(y,N),H=t.add(H,l),l=t.mul(_,N),E=t.mul(S,E),E=t.sub(E,l),l=t.mul(S,y),B=t.mul(_,B),B=t.add(B,l),new g(E,H,B)}subtract(a){return this.add(a.negate())}is0(){return this.equals(g.ZERO)}wNAF(a){return G.wNAFCached(this,a,g.normalizeZ)}multiplyUnsafe(a){const{endo:b,n:m}=n;bt("scalar",a,J,m);const A=g.ZERO;if(a===J)return A;if(this.is0()||a===z)return this;if(!b||G.hasPrecomputes(this))return G.wNAFCachedUnsafe(this,a,g.normalizeZ);let{k1neg:v,k1:O,k2neg:q,k2:E}=b.splitScalar(a),H=A,B=A,T=this;for(;O>J||E>J;)O&z&&(H=H.add(T)),E&z&&(B=B.add(T)),T=T.double(),O>>=z,E>>=z;return v&&(H=H.negate()),q&&(B=B.negate()),B=new g(t.mul(B.px,b.beta),B.py,B.pz),H.add(B)}multiply(a){const{endo:b,n:m}=n;bt("scalar",a,z,m);let A,v;if(b){const{k1neg:O,k1:q,k2neg:E,k2:H}=b.splitScalar(a);let{p:B,f:T}=this.wNAF(q),{p:u,f:l}=this.wNAF(H);B=G.constTimeNegate(O,B),u=G.constTimeNegate(E,u),u=new g(t.mul(u.px,b.beta),u.py,u.pz),A=B.add(u),v=T.add(l)}else{const{p:O,f:q}=this.wNAF(a);A=O,v=q}return g.normalizeZ([A,v])[0]}multiplyAndAddUnsafe(a,b,m){const A=g.BASE,v=(q,E)=>E===J||E===z||!q.equals(A)?q.multiplyUnsafe(E):q.multiply(E),O=v(this,b).add(v(a,m));return O.is0()?void 0:O}toAffine(a){return I(this,a)}isTorsionFree(){const{h:a,isTorsionFree:b}=n;if(a===z)return!0;if(b)return b(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:b}=n;return a===z?this:b?b(g,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return yt("isCompressed",a),this.assertValidity(),i(g,this,a)}toHex(a=!0){return yt("isCompressed",a),mt(this.toRawBytes(a))}}g.BASE=new g(n.Gx,n.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:R,nBitLength:C}=n,G=yn(g,R?Math.ceil(C/2):C);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:h,weierstrassEquation:f,isWithinCurveOrder:x}}function Sn(e){const n=Oe(e);return qt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Hn(e){const n=Sn(e),{Fp:t,n:r,nByteLength:i,nBitLength:o}=n,f=t.BYTES+1,c=2*t.BYTES+1;function s(u){return j(u,r)}function d(u){return Dt(u,r)}const{ProjectivePoint:x,normPrivateKeyToScalar:h,weierstrassEquation:p,isWithinCurveOrder:I}=vn({...n,toBytes(u,l,y){const L=l.toAffine(),S=t.toBytes(L.x),N=Ot;return yt("isCompressed",y),y?N(Uint8Array.from([l.hasEvenY()?2:3]),S):N(Uint8Array.from([4]),S,t.toBytes(L.y))},fromBytes(u){const l=u.length,y=u[0],L=u.subarray(1);if(l===f&&(y===2||y===3)){const S=ct(L);if(!Pt(S,z,t.ORDER))throw new Error("Point is not on curve");const N=p(S);let _;try{_=t.sqrt(N)}catch(Y){const K=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+K)}const V=(_&z)===z;return(y&1)===1!==V&&(_=t.neg(_)),{x:S,y:_}}else if(l===c&&y===4){const S=t.fromBytes(L.subarray(0,t.BYTES)),N=t.fromBytes(L.subarray(t.BYTES,2*t.BYTES));return{x:S,y:N}}else{const S=f,N=c;throw new Error("invalid Point, expected length of "+S+", or uncompressed "+N+", got "+l)}}});function U(u){const l=r>>z;return u>l}function g(u){return U(u)?s(-u):u}const R=(u,l,y)=>ct(u.slice(l,y));class C{constructor(l,y,L){bt("r",l,z,r),bt("s",y,z,r),this.r=l,this.s=y,L!=null&&(this.recovery=L),Object.freeze(this)}static fromCompact(l){const y=i;return l=F("compactSignature",l,y*2),new C(R(l,0,y),R(l,y,2*y))}static fromDER(l){const{r:y,s:L}=Q.toSig(F("DER",l));return new C(y,L)}assertValidity(){}addRecoveryBit(l){return new C(this.r,this.s,l)}recoverPublicKey(l){const{r:y,s:L,recovery:S}=this,N=A(F("msgHash",l));if(S==null||![0,1,2,3].includes(S))throw new Error("recovery id invalid");const _=S===2||S===3?y+n.n:y;if(_>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=(S&1)===0?"02":"03",P=x.fromHex(V+Mt(_,t.BYTES)),Y=d(_),K=s(-N*Y),at=s(L*Y),tt=x.BASE.multiplyAndAddUnsafe(P,K,at);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new C(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return Nt(this.toDERHex())}toDERHex(){return Q.hexFromSig(this)}toCompactRawBytes(){return Nt(this.toCompactHex())}toCompactHex(){const l=i;return Mt(this.r,l)+Mt(this.s,l)}}const G={isValidPrivateKey(u){try{return h(u),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const u=ve(n.n);return wn(n.randomBytes(u),n.n)},precompute(u=8,l=x.BASE){return l._setWindowSize(u),l.multiply(BigInt(3)),l}};function w(u,l=!0){return x.fromPrivateKey(u).toRawBytes(l)}function a(u){if(typeof u=="bigint")return!1;if(u instanceof x)return!0;const y=F("key",u).length,L=t.BYTES,S=L+1,N=2*L+1;if(!(n.allowedPrivateKeyLengths||i===S))return y===S||y===N}function b(u,l,y=!0){if(a(u)===!0)throw new Error("first arg must be private key");if(a(l)===!1)throw new Error("second arg must be public key");return x.fromHex(l).multiply(h(u)).toRawBytes(y)}const m=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const l=ct(u),y=u.length*8-o;return y>0?l>>BigInt(y):l},A=n.bits2int_modN||function(u){return s(m(u))},v=Lt(o);function O(u){return bt("num < 2^"+o,u,J,v),Bt(u,i)}function q(u,l,y=E){if(["recovered","canonical"].some(it=>it in y))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:S}=n;let{lowS:N,prehash:_,extraEntropy:V}=y;N==null&&(N=!0),u=F("msgHash",u),ie(y),_&&(u=F("prehashed msgHash",L(u)));const P=A(u),Y=h(l),K=[O(Y),O(P)];if(V!=null&&V!==!1){const it=V===!0?S(t.BYTES):V;K.push(F("extraEntropy",it))}const at=Ot(...K),tt=P;function Ut(it){const lt=m(it);if(!I(lt))return;const Ct=d(lt),wt=x.BASE.multiply(lt).toAffine(),ot=s(wt.x);if(ot===J)return;const xt=s(Ct*s(tt+ot*Y));if(xt===J)return;let pt=(wt.x===ot?0:2)|Number(wt.y&z),dt=xt;return N&&U(xt)&&(dt=g(xt),pt^=1),new C(ot,dt,pt)}return{seed:at,k2sig:Ut}}const E={lowS:n.lowS,prehash:!1},H={lowS:n.lowS,prehash:!1};function B(u,l,y=E){const{seed:L,k2sig:S}=q(u,l,y),N=n;return Pe(N.hash.outputLen,N.nByteLength,N.hmac)(L,S)}x.BASE._setWindowSize(8);function T(u,l,y,L=H){var pt;const S=u;l=F("msgHash",l),y=F("publicKey",y);const{lowS:N,prehash:_,format:V}=L;if(ie(L),"strict"in L)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");const P=typeof S=="string"||Et(S),Y=!P&&!V&&typeof S=="object"&&S!==null&&typeof S.r=="bigint"&&typeof S.s=="bigint";if(!P&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,at;try{if(Y&&(K=new C(S.r,S.s)),P){try{V!=="compact"&&(K=C.fromDER(S))}catch(dt){if(!(dt instanceof Q.Err))throw dt}!K&&V!=="der"&&(K=C.fromCompact(S))}at=x.fromHex(y)}catch{return!1}if(!K||N&&K.hasHighS())return!1;_&&(l=n.hash(l));const{r:tt,s:Ut}=K,it=A(l),lt=d(Ut),Ct=s(it*lt),wt=s(tt*lt),ot=(pt=x.BASE.multiplyAndAddUnsafe(at,Ct,wt))==null?void 0:pt.toAffine();return ot?s(ot.x)===tt:!1}return{CURVE:n,getPublicKey:w,getSharedSecret:b,sign:B,verify:T,ProjectivePoint:x,Signature:C,utils:G}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function In(e){return{hash:e,hmac:(n,...t)=>He(e,n,De(...t)),randomBytes:Ke}}function $t(e,n){const t=r=>Hn({...e,...In(r)});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Le=At(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Nn=Le.create(BigInt("-3")),On=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Ln=$t({a:Nn,b:On,Fp:Le,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},on),qe=At(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),qn=qe.create(BigInt("-3")),Un=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");$t({a:qn,b:Un,Fp:qe,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},cn);const Ue=At(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),Cn=Ue.create(BigInt("-3")),_n=BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");$t({a:Cn,b:_n,Fp:Ue,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1),lowS:!1,allowedPrivateKeyLengths:[130,131,132]},fn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=Ln,Tn=async e=>{const n=oe.getPublicKey(e.privateKey,!0),t=Fe(n);if(t!=e.publicKey)throw new Error(`Bad API key. Expected to get public key ${e.publicKey}, got ${t}`);const r=je().update(e.content).digest();return oe.sign(r,e.privateKey).toDERHex()};export{Tn as signWithApiKey};
